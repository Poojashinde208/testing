{
  "version": 3,
  "sources": ["../../../../../../node_modules/rope-sequence/dist/index.js", "../../../../../../node_modules/prosemirror-history/dist/index.js", "../../../../../../node_modules/@tiptap/extension-history/dist/index.js"],
  "sourcesContent": ["var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence() {};\nRopeSequence.prototype.append = function append(other) {\n  if (!other.length) {\n    return this;\n  }\n  other = RopeSequence.from(other);\n  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend(other) {\n  if (!other.length) {\n    return this;\n  }\n  return RopeSequence.from(other).append(this);\n};\nRopeSequence.prototype.appendInner = function appendInner(other) {\n  return new Append(this, other);\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice(from, to) {\n  if (from === void 0) from = 0;\n  if (to === void 0) to = this.length;\n  if (from >= to) {\n    return RopeSequence.empty;\n  }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to));\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) {\n    return undefined;\n  }\n  return this.getInner(i);\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach(f, from, to) {\n  if (from === void 0) from = 0;\n  if (to === void 0) to = this.length;\n  if (from <= to) {\n    this.forEachInner(f, from, to, 0);\n  } else {\n    this.forEachInvertedInner(f, from, to, 0);\n  }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map(f, from, to) {\n  if (from === void 0) from = 0;\n  if (to === void 0) to = this.length;\n  var result = [];\n  this.forEach(function (elt, i) {\n    return result.push(f(elt, i));\n  }, from, to);\n  return result;\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from(values) {\n  if (values instanceof RopeSequence) {\n    return values;\n  }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty;\n};\nvar Leaf = /*@__PURE__*/function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n  if (RopeSequence) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create(RopeSequence && RopeSequence.prototype);\n  Leaf.prototype.constructor = Leaf;\n  var prototypeAccessors = {\n    length: {\n      configurable: true\n    },\n    depth: {\n      configurable: true\n    }\n  };\n  Leaf.prototype.flatten = function flatten() {\n    return this.values;\n  };\n  Leaf.prototype.sliceInner = function sliceInner(from, to) {\n    if (from == 0 && to == this.length) {\n      return this;\n    }\n    return new Leaf(this.values.slice(from, to));\n  };\n  Leaf.prototype.getInner = function getInner(i) {\n    return this.values[i];\n  };\n  Leaf.prototype.forEachInner = function forEachInner(f, from, to, start) {\n    for (var i = from; i < to; i++) {\n      if (f(this.values[i], start + i) === false) {\n        return false;\n      }\n    }\n  };\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {\n    for (var i = from - 1; i >= to; i--) {\n      if (f(this.values[i], start + i) === false) {\n        return false;\n      }\n    }\n  };\n  Leaf.prototype.leafAppend = function leafAppend(other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE) {\n      return new Leaf(this.values.concat(other.flatten()));\n    }\n  };\n  Leaf.prototype.leafPrepend = function leafPrepend(other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE) {\n      return new Leaf(other.flatten().concat(this.values));\n    }\n  };\n  prototypeAccessors.length.get = function () {\n    return this.values.length;\n  };\n  prototypeAccessors.depth.get = function () {\n    return 0;\n  };\n  Object.defineProperties(Leaf.prototype, prototypeAccessors);\n  return Leaf;\n}(RopeSequence);\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\nvar Append = /*@__PURE__*/function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n  if (RopeSequence) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create(RopeSequence && RopeSequence.prototype);\n  Append.prototype.constructor = Append;\n  Append.prototype.flatten = function flatten() {\n    return this.left.flatten().concat(this.right.flatten());\n  };\n  Append.prototype.getInner = function getInner(i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);\n  };\n  Append.prototype.forEachInner = function forEachInner(f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen && this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false) {\n      return false;\n    }\n    if (to > leftLen && this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {\n      return false;\n    }\n  };\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen && this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {\n      return false;\n    }\n    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false) {\n      return false;\n    }\n  };\n  Append.prototype.sliceInner = function sliceInner(from, to) {\n    if (from == 0 && to == this.length) {\n      return this;\n    }\n    var leftLen = this.left.length;\n    if (to <= leftLen) {\n      return this.left.slice(from, to);\n    }\n    if (from >= leftLen) {\n      return this.right.slice(from - leftLen, to - leftLen);\n    }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen));\n  };\n  Append.prototype.leafAppend = function leafAppend(other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) {\n      return new Append(this.left, inner);\n    }\n  };\n  Append.prototype.leafPrepend = function leafPrepend(other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) {\n      return new Append(inner, this.right);\n    }\n  };\n  Append.prototype.appendInner = function appendInner(other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {\n      return new Append(this.left, new Append(this.right, other));\n    }\n    return new Append(this, other);\n  };\n  return Append;\n}(RopeSequence);\nexport default RopeSequence;", "import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items;\n    this.eventCount = eventCount;\n  }\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null;\n    let end = this.items.length;\n    for (;; end--) {\n      let next = this.items.get(end - 1);\n      if (next.selection) {\n        --end;\n        break;\n      }\n    }\n    let remap, mapFrom;\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length);\n      mapFrom = remap.maps.length;\n    }\n    let transform = state.tr;\n    let selection, remaining;\n    let addAfter = [],\n      addBefore = [];\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1);\n          mapFrom = remap.maps.length;\n        }\n        mapFrom--;\n        addBefore.push(item);\n        return;\n      }\n      if (remap) {\n        addBefore.push(new Item(item.map));\n        let step = item.step.map(remap.slice(mapFrom)),\n          map;\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1];\n          addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n        }\n        mapFrom--;\n        if (map) remap.appendMap(map, mapFrom);\n      } else {\n        transform.maybeStep(item.step);\n      }\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n        return false;\n      }\n    }, this.items.length, 0);\n    return {\n      remaining: remaining,\n      transform,\n      selection: selection\n    };\n  }\n  // Create a new branch with the given transform added.\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [],\n      eventCount = this.eventCount;\n    let oldItems = this.items,\n      lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i]);\n      let item = new Item(transform.mapping.maps[i], step, selection),\n        merged;\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged;\n        if (i) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);\n      }\n      newItems.push(item);\n      if (selection) {\n        eventCount++;\n        selection = undefined;\n      }\n      if (!preserveItems) lastItem = item;\n    }\n    let overflow = eventCount - histOptions.depth;\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow);\n      eventCount -= overflow;\n    }\n    return new Branch(oldItems.append(newItems), eventCount);\n  }\n  remapping(from, to) {\n    let maps = new Mapping();\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;\n      maps.appendMap(item.map, mirrorPos);\n    }, from, to);\n    return maps;\n  }\n  addMaps(array) {\n    if (this.eventCount == 0) return this;\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n  }\n  // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this;\n    let rebasedItems = [],\n      start = Math.max(0, this.items.length - rebasedCount);\n    let mapping = rebasedTransform.mapping;\n    let newUntil = rebasedTransform.steps.length;\n    let eventCount = this.eventCount;\n    this.items.forEach(item => {\n      if (item.selection) eventCount--;\n    }, start);\n    let iRebased = rebasedCount;\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased);\n      if (pos == null) return;\n      newUntil = Math.min(newUntil, pos);\n      let map = mapping.maps[pos];\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n        if (selection) eventCount++;\n        rebasedItems.push(new Item(map, step, selection));\n      } else {\n        rebasedItems.push(new Item(map));\n      }\n    }, start);\n    let newMaps = [];\n    for (let i = rebasedCount; i < newUntil; i++) newMaps.push(new Item(mapping.maps[i]));\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n    let branch = new Branch(items, eventCount);\n    if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);\n    return branch;\n  }\n  emptyItemCount() {\n    let count = 0;\n    this.items.forEach(item => {\n      if (!item.step) count++;\n    });\n    return count;\n  }\n  // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n  compress(upto = this.items.length) {\n    let remap = this.remapping(0, upto),\n      mapFrom = remap.maps.length;\n    let items = [],\n      events = 0;\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item);\n        if (item.selection) events++;\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)),\n          map = step && step.getMap();\n        mapFrom--;\n        if (map) remap.appendMap(map, mapFrom);\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n          if (selection) events++;\n          let newItem = new Item(map.invert(), step, selection),\n            merged,\n            last = items.length - 1;\n          if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);\n        }\n      } else if (item.map) {\n        mapFrom--;\n      }\n    }, this.items.length, 0);\n    return new Branch(RopeSequence.from(items.reverse()), events);\n  }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n  let cutPoint;\n  items.forEach((item, i) => {\n    if (item.selection && n-- == 0) {\n      cutPoint = i;\n      return false;\n    }\n  });\n  return items.slice(cutPoint);\n}\nclass Item {\n  constructor(\n  // The (forward) step map for this item.\n  map,\n  // The inverted step\n  step,\n  // If this is non-null, this item is the start of a group, and\n  // this selection is the starting selection for the group (the one\n  // that was active before the first step was applied)\n  selection,\n  // If this item is the inverse of a previous mapping on the stack,\n  // this points at the inverse's offset\n  mirrorOffset) {\n    this.map = map;\n    this.step = step;\n    this.selection = selection;\n    this.mirrorOffset = mirrorOffset;\n  }\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step);\n      if (step) return new Item(step.getMap().invert(), step, this.selection);\n    }\n  }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n  constructor(done, undone, prevRanges, prevTime, prevComposition) {\n    this.done = done;\n    this.undone = undone;\n    this.prevRanges = prevRanges;\n    this.prevTime = prevTime;\n    this.prevComposition = prevComposition;\n  }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey),\n    rebased;\n  if (historyTr) return historyTr.historyState;\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0, -1);\n  let appended = tr.getMeta(\"appendedTransaction\");\n  if (tr.steps.length == 0) {\n    return history;\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let composition = tr.getMeta(\"composition\");\n    let newGroup = history.prevTime == 0 || !appended && history.prevComposition != composition && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n  }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false;\n  if (!transform.docChanged) return true;\n  let adjacent = false;\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2) if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;\n  });\n  return adjacent;\n}\nfunction rangesFor(maps) {\n  let result = [];\n  for (let i = maps.length - 1; i >= 0 && result.length == 0; i--) maps[i].forEach((_from, _to, from, to) => result.push(from, to));\n  return result;\n}\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null;\n  let result = [];\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1),\n      to = mapping.map(ranges[i + 1], -1);\n    if (from <= to) result.push(from, to);\n  }\n  return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n  let preserveItems = mustPreserveItems(state);\n  let histOptions = historyKey.get(state).spec.config;\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n  if (!pop) return null;\n  let selection = pop.selection.resolve(pop.transform.doc);\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n  return pop.transform.setSelection(selection).setMeta(historyKey, {\n    redo,\n    historyState: newHist\n  });\n}\nlet cachedPreserveItems = false,\n  cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins;\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true;\n      break;\n    }\n  }\n  return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n  config = {\n    depth: config.depth || 100,\n    newGroupDelay: config.newGroupDelay || 500\n  };\n  return new Plugin({\n    key: historyKey,\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config);\n      }\n    },\n    config,\n    props: {\n      handleDOMEvents: {\n        beforeinput(view, e) {\n          let inputType = e.inputType;\n          let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n          if (!command) return false;\n          e.preventDefault();\n          return command(view.state, view.dispatch);\n        }\n      }\n    }\n  });\n}\nfunction buildCommand(redo, scroll) {\n  return (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || (redo ? hist.undone : hist.done).eventCount == 0) return false;\n    if (dispatch) {\n      let tr = histTransaction(hist, state, redo);\n      if (tr) dispatch(scroll ? tr.scrollIntoView() : tr);\n    }\n    return true;\n  };\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/\nconst undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/\nconst redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n  let hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n  let hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0;\n}\nexport { closeHistory, history, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };", "import { Extension } from '@tiptap/core';\nimport { undo, redo, history } from '@tiptap/pm/history';\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/history\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `history` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */\nconst History = Extension.create({\n  name: 'history',\n  addOptions() {\n    return {\n      depth: 100,\n      newGroupDelay: 500\n    };\n  },\n  addCommands() {\n    return {\n      undo: () => ({\n        state,\n        dispatch\n      }) => {\n        return undo(state, dispatch);\n      },\n      redo: () => ({\n        state,\n        dispatch\n      }) => {\n        return redo(state, dispatch);\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    return [history(this.options)];\n  },\n  addKeyboardShortcuts() {\n    return {\n      'Mod-z': () => this.editor.commands.undo(),\n      'Shift-Mod-z': () => this.editor.commands.redo(),\n      'Mod-y': () => this.editor.commands.redo(),\n      // Russian keyboard layouts\n      'Mod-я': () => this.editor.commands.undo(),\n      'Shift-Mod-я': () => this.editor.commands.redo()\n    };\n  }\n});\nexport { History, History as default };\n"],
  "mappings": "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",
  "names": ["RopeSequence", "from", "Leaf", "Append", "appendInner", "map", "from", "history", "redo", "redo"]
}
